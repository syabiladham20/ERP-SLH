{% extends 'base.html' %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h2>Custom Dashboard: {{ flock.house.name }}</h2>
    <div>
        <div class="btn-group me-2" role="group">
            <input type="radio" class="btn-check" name="viewMode" id="viewCharts" autocomplete="off" checked>
            <label class="btn btn-outline-primary" for="viewCharts">Charts</label>

            <input type="radio" class="btn-check" name="viewMode" id="viewTable" autocomplete="off">
            <label class="btn btn-outline-primary" for="viewTable">Overview Table</label>
        </div>
        <a href="{{ url_for('view_flock', id=flock.id) }}" class="btn btn-secondary">Back to Flock</a>
    </div>
</div>

<!-- Controls Toolbar -->
<div class="row mb-3" id="chartsToolbar">
    <div class="col-md-6">
        <button class="btn btn-success" data-bs-toggle="modal" data-bs-target="#chartModal" onclick="prepareAddChart()">
            <i class="bi bi-plus-lg"></i> Add Chart
        </button>
        <button class="btn btn-info text-white" data-bs-toggle="modal" data-bs-target="#templatesModal" onclick="loadTemplates()">
            Import Template
        </button>
    </div>
    <div class="col-md-6 d-flex gap-2 justify-content-end align-items-center">
        <label>From:</label>
        <input type="date" id="startDate" class="form-control form-control-sm" style="width: 130px;">
        <label>To:</label>
        <input type="date" id="endDate" class="form-control form-control-sm" style="width: 130px;">
        <button class="btn btn-primary btn-sm" onclick="loadDashboardConfig()">Update</button>
    </div>
</div>

<div class="row mb-3 d-none" id="tableToolbar">
    <div class="col">
        <button class="btn btn-secondary" data-bs-toggle="modal" data-bs-target="#tableConfigModal">
            Configure Columns
        </button>
        <button class="btn btn-outline-success" onclick="exportTableToExcel()">
            Export to Excel
        </button>
    </div>
</div>

<!-- Charts Container -->
<div id="chartsContainer" class="row g-4">
    <!-- Dynamic Charts -->
</div>

<!-- Table Container -->
<div id="tableContainer" class="table-responsive table-responsive-sticky d-none">
    <table class="table table-striped table-bordered table-sm" id="overviewTable">
        <thead class="table-dark sticky-table-header">
            <tr id="tableHeadRow">
                <!-- Dynamic Headers -->
            </tr>
        </thead>
        <tbody id="tableBody">
            <!-- Dynamic Rows -->
        </tbody>
    </table>
</div>

<!-- Add/Edit Chart Modal -->
<div class="modal fade" id="chartModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="chartModalTitle">Add Chart</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="chartForm">
                    <input type="hidden" id="chartId">
                    <div class="mb-3">
                        <label class="form-label">Chart Title</label>
                        <input type="text" class="form-control" id="chartTitle" required>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Chart Type</label>
                        <select class="form-select" id="chartType">
                            <option value="line">Line Chart</option>
                            <option value="bar">Bar Chart (Clustered)</option>
                            <option value="stacked_bar">Stacked Bar Chart</option>
                            <option value="combo">Combo (Bar + Line)</option>
                            <option value="combo_stacked">Combo (Stacked Bar + Line)</option>
                        </select>
                    </div>

                    <div class="row">
                        <div class="col-md-6">
                            <h6>Left Axis Metrics</h6>
                            <div class="list-group" id="leftAxisMetrics" style="max-height: 300px; overflow-y: auto;">
                                <!-- Dynamic Checkboxes -->
                            </div>
                        </div>
                        <div class="col-md-6">
                            <h6>Right Axis Metrics (Optional)</h6>
                            <div class="list-group" id="rightAxisMetrics" style="max-height: 300px; overflow-y: auto;">
                                <!-- Dynamic Checkboxes -->
                            </div>
                        </div>
                    </div>

                    <div class="mt-3 form-check">
                        <input type="checkbox" class="form-check-input" id="isTemplate">
                        <label class="form-check-label">Save as Global Template</label>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-danger me-auto" id="btnDeleteChart" style="display:none;" onclick="deleteChart()">Delete</button>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" onclick="saveChart()">Save Chart</button>
            </div>
        </div>
    </div>
</div>

<!-- Table Config Modal -->
<div class="modal fade" id="tableConfigModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Configure Overview Table</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="list-group" id="tableMetricsList" style="max-height: 400px; overflow-y: auto;">
                    <!-- Dynamic Checkboxes -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" onclick="saveTableConfig()">Save Configuration</button>
            </div>
        </div>
    </div>
</div>

<!-- Templates Modal -->
<div class="modal fade" id="templatesModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Import from Template</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="list-group" id="templatesList">
                    <!-- Dynamic Templates -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Note Modal -->
<div class="modal fade" id="customNoteModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customNoteModalTitle">Clinical Note</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body text-center">
        <div id="customNoteModalPhoto" class="mb-3" style="display: none;">
          <img src="" class="img-fluid rounded border" alt="Clinical Photo">
        </div>
        <p id="customNoteModalText" class="lead"></p>
        <p id="customNoteModalDate" class="text-muted small"></p>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    const HOUSE_ID = {{ flock.house_id }};
    const FLOCK_ID = {{ flock.id }};

    let METRICS_META = {};
    let CHART_INSTANCES = {};
    let CURRENT_DATA = {};
    let CONFIG = { charts: [], overview_columns: [] };

    document.addEventListener('DOMContentLoaded', function() {
        // Init View Toggles
        document.getElementById('viewCharts').addEventListener('change', toggleView);
        document.getElementById('viewTable').addEventListener('change', toggleView);

        loadMetricsMeta().then(() => {
            loadDashboardConfig();
        });
    });

    function toggleView() {
        const isCharts = document.getElementById('viewCharts').checked;
        if (isCharts) {
            document.getElementById('chartsContainer').classList.remove('d-none');
            document.getElementById('chartsToolbar').classList.remove('d-none');
            document.getElementById('tableContainer').classList.add('d-none');
            document.getElementById('tableToolbar').classList.add('d-none');
        } else {
            document.getElementById('chartsContainer').classList.add('d-none');
            document.getElementById('chartsToolbar').classList.add('d-none');
            document.getElementById('tableContainer').classList.remove('d-none');
            document.getElementById('tableToolbar').classList.remove('d-none');
            renderTable(); // Refresh table
        }
    }

    async function loadMetricsMeta() {
        const res = await fetch('/api/metrics');
        METRICS_META = await res.json();

        // Populate Modal Lists
        const leftList = document.getElementById('leftAxisMetrics');
        const rightList = document.getElementById('rightAxisMetrics');
        const tableList = document.getElementById('tableMetricsList');

        leftList.innerHTML = '';
        rightList.innerHTML = '';
        tableList.innerHTML = '';

        // Sort metrics by label
        const sortedKeys = Object.keys(METRICS_META).sort((a,b) => METRICS_META[a].label.localeCompare(METRICS_META[b].label));

        sortedKeys.forEach(key => {
            const m = METRICS_META[key];

            // For Charts: Checkbox + Type Select
            const chartItem = (prefix) => `
                <div class="list-group-item p-1">
                    <div class="d-flex align-items-center">
                        <input class="form-check-input me-2" type="checkbox" value="${key}" id="${prefix}_check_${key}">
                        <label class="form-check-label small flex-grow-1 text-wrap" for="${prefix}_check_${key}">
                            ${m.label} <small class="text-muted">(${m.unit})</small>
                        </label>
                        <select class="form-select form-select-sm py-0 ps-1 pe-3" id="${prefix}_type_${key}" style="width: 70px; height: 24px; font-size: 0.75rem;">
                            <option value="">Default</option>
                            <option value="line">Line</option>
                            <option value="bar">Bar</option>
                        </select>
                    </div>
                </div>`;

            // For Table: Simple Checkbox
            const tblItem = `
                <label class="list-group-item">
                    <input class="form-check-input me-1" type="checkbox" value="${key}" id="tbl_${key}">
                    ${m.label}
                </label>`;

            leftList.insertAdjacentHTML('beforeend', chartItem('left'));
            rightList.insertAdjacentHTML('beforeend', chartItem('right'));
            tableList.insertAdjacentHTML('beforeend', tblItem);
        });
    }

    async function loadDashboardConfig() {
        const res = await fetch(`/api/house/${HOUSE_ID}/dashboard_config`);
        CONFIG = await res.json();

        // Identify all metrics needed
        const metricsNeeded = new Set(['dates', 'weeks']); // always needed

        CONFIG.charts.forEach(c => {
            if (c.config.metrics) c.config.metrics.forEach(m => metricsNeeded.add(m));
            if (c.config.metrics_right) c.config.metrics_right.forEach(m => metricsNeeded.add(m));
        });

        if (CONFIG.overview_columns) {
            CONFIG.overview_columns.forEach(m => metricsNeeded.add(m));
        } else {
            // Default columns if none set
            CONFIG.overview_columns = ['mortality_female_pct', 'egg_prod_pct', 'body_weight_female'];
            CONFIG.overview_columns.forEach(m => metricsNeeded.add(m));
        }

        const payload = {
            metrics: Array.from(metricsNeeded),
            start_date: document.getElementById('startDate').value,
            end_date: document.getElementById('endDate').value
        };

        // Fetch Data
        const dataRes = await fetch(`/api/flock/${FLOCK_ID}/custom_data`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });

        CURRENT_DATA = await dataRes.json();

        renderCharts();
        renderTable();
    }

    function renderCharts() {
        const container = document.getElementById('chartsContainer');
        container.innerHTML = '';
        CHART_INSTANCES = {};

        CONFIG.charts.forEach(chart => {
            const col = document.createElement('div');
            col.className = 'col-md-6 col-lg-6';

            const card = document.createElement('div');
            card.className = 'card h-100 shadow-sm';

            const cardHeader = document.createElement('div');
            cardHeader.className = 'card-header d-flex justify-content-between align-items-center';

            const title = document.createElement('h6');
            title.className = 'mb-0 fw-bold';
            title.textContent = chart.title;

            const btn = document.createElement('button');
            btn.className = 'btn btn-sm btn-outline-secondary';
            btn.innerHTML = '<i class="bi bi-gear"></i> Edit';
            btn.onclick = function() { editChart(chart.id); };

            cardHeader.appendChild(title);
            cardHeader.appendChild(btn);

            const cardBody = document.createElement('div');
            cardBody.className = 'card-body';

            const canvas = document.createElement('canvas');
            canvas.id = `chartCanvas_${chart.id}`;

            cardBody.appendChild(canvas);
            card.appendChild(cardHeader);
            card.appendChild(cardBody);
            col.appendChild(card);

            container.appendChild(col);

            drawChart(chart, `chartCanvas_${chart.id}`);
        });
    }

    function drawChart(chart, canvasId) {
        const ctx = document.getElementById(canvasId).getContext('2d');

        const datasets = [];
        const leftMetrics = chart.config.metrics || [];
        const rightMetrics = chart.config.metrics_right || [];
        const metricTypes = chart.config.types || {};

        const colors = ['#007bff', '#28a745', '#dc3545', '#ffc107', '#17a2b8', '#6610f2', '#fd7e14', '#20c997'];
        let colorIdx = 0;

        // Determine Defaults based on Chart Type
        let mainType = 'line';
        let leftTypeDefault = 'line';
        let rightTypeDefault = 'line';
        let isStacked = false;

        if (chart.chart_type === 'bar') {
            mainType = 'bar'; leftTypeDefault = 'bar'; rightTypeDefault = 'bar';
        } else if (chart.chart_type === 'stacked_bar') {
            mainType = 'bar'; leftTypeDefault = 'bar'; rightTypeDefault = 'bar'; isStacked = true;
        } else if (chart.chart_type === 'combo') {
            mainType = 'bar'; leftTypeDefault = 'bar'; rightTypeDefault = 'line';
        } else if (chart.chart_type === 'combo_stacked') {
            mainType = 'bar'; leftTypeDefault = 'bar'; rightTypeDefault = 'line'; isStacked = true;
        }

        function addDataset(m, axis, defaultType) {
            if (!CURRENT_DATA[m]) return;

            // Use per-metric type if set, otherwise default
            let type = metricTypes[m] || defaultType;
            if (type === '') type = defaultType;

            const color = colors[colorIdx % colors.length];

            datasets.push({
                label: METRICS_META[m]?.label || m,
                data: CURRENT_DATA[m],
                borderColor: color,
                backgroundColor: color,
                yAxisID: axis,
                type: type,
                tension: 0.1,
                spanGaps: true,
                fill: false,
                borderWidth: type === 'bar' ? 1 : 2,
                pointRadius: type === 'line' ? 2 : 0,
                stack: (isStacked && type === 'bar') ? 'stack0' : undefined
            });
            colorIdx++;
        }

        leftMetrics.forEach(m => addDataset(m, 'y', leftTypeDefault));
        rightMetrics.forEach(m => addDataset(m, 'y1', rightTypeDefault));

        const hasRight = rightMetrics.length > 0;

        // Calculate Scale Options
        let leftValues = [];
        let rightValues = [];
        leftMetrics.forEach(m => {
            if (CURRENT_DATA[m]) leftValues.push(...CURRENT_DATA[m]);
        });
        rightMetrics.forEach(m => {
            if (CURRENT_DATA[m]) rightValues.push(...CURRENT_DATA[m]);
        });

        function getScaleOptions(values, isPercentage) {
             const valid = values.filter(v => v !== null && v !== undefined && !isNaN(v));
             if (!valid || valid.length === 0) return {min: 0, suggestedMax: isPercentage ? 100 : 10};
             const maxVal = Math.max(...valid);
             let limit = maxVal * 1.25;
             if (limit === 0) return {min: 0, suggestedMax: isPercentage ? 100 : 1};

             if (isPercentage && limit > 100) return {min: 0, max: 100};
             return {min: 0, suggestedMax: limit};
        }

        const leftIsPct = leftMetrics.length > 0 && leftMetrics.every(m => METRICS_META[m]?.unit?.includes('%'));
        const rightIsPct = rightMetrics.length > 0 && rightMetrics.every(m => METRICS_META[m]?.unit?.includes('%'));

        const leftScale = getScaleOptions(leftValues, leftIsPct);
        const rightScale = getScaleOptions(rightValues, rightIsPct);

        // Prepare Notes Dataset (Scatter)
        // We use xLabels (Category Scale) for X, and map Y to first available metric value.
        const notesPoints = CURRENT_DATA.dates.map((d, i) => {
            // Find event for this date
            const ev = CURRENT_DATA.events ? CURRENT_DATA.events.find(e => e.date === d) : null;
            if (ev) {
                // Find a visible Y value to anchor to.
                // Try left metrics first.
                let yVal = 0;
                let axisID = 'y';
                if (leftMetrics.length > 0 && CURRENT_DATA[leftMetrics[0]]) {
                     yVal = CURRENT_DATA[leftMetrics[0]][i] || 0;
                     axisID = 'y';
                } else if (rightMetrics.length > 0 && CURRENT_DATA[rightMetrics[0]]) {
                     yVal = CURRENT_DATA[rightMetrics[0]][i] || 0;
                     axisID = 'y1';
                }

                // If no metrics, yVal = 0
                return {
                    x: xLabels[i], // Align with X Axis Labels
                    y: yVal,
                    note: ev.note,
                    photo: ev.photo,
                    date: d
                };
            }
            return null;
        });

        // Add Notes Dataset
        datasets.push({
            label: 'Clinical Notes',
            data: notesPoints,
            type: 'scatter',
            yAxisID: 'y', // Just anchor to left axis for scaling
            pointStyle: 'rectRot',
            pointRadius: 6,
            pointHoverRadius: 8,
            backgroundColor: 'purple',
            borderColor: 'purple',
            hidden: true,
            datalabels: { display: false }
        });

        // Custom Title Construction
        const metricNames = [...leftMetrics, ...rightMetrics].map(m => METRICS_META[m]?.label || m).join(', ');
        const dateRange = CURRENT_DATA.dates.length > 0 ?
            `${CURRENT_DATA.dates[0]} – ${CURRENT_DATA.dates[CURRENT_DATA.dates.length-1]}` : '';
        const weekRange = CURRENT_DATA.weeks.length > 0 ?
            `${CURRENT_DATA.weeks[0]}–${CURRENT_DATA.weeks[CURRENT_DATA.weeks.length-1]} wk` : '';

        const dynamicTitle = `${metricNames} - {{ flock.house.name }} (${dateRange}, ${weekRange})`;

        // Prepare X Labels (Date + Week/Age)
        const xLabels = CURRENT_DATA.dates.map((d, i) => {
            const dateObj = new Date(d);
            const dayMonth = `${dateObj.getDate()}/${dateObj.getMonth()+1}`;
            return `${dayMonth} (${CURRENT_DATA.weeks[i]} wk)`;
        });

        // Week Partition Plugin
        const weekPartitionPlugin = {
            id: 'weekPartition',
            beforeDraw: (chart) => {
                const ctx = chart.ctx;
                const xAxis = chart.scales.x;
                const top = chart.scales.y.top;
                const bottom = chart.scales.y.bottom;

                ctx.save();
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.setLineDash([5, 5]);

                // Detect week changes
                for (let i = 1; i < CURRENT_DATA.weeks.length; i++) {
                    if (CURRENT_DATA.weeks[i] !== CURRENT_DATA.weeks[i-1]) {
                         const x = xAxis.getPixelForValue(i);
                         ctx.moveTo(x, top);
                         ctx.lineTo(x, bottom);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }
        };

        CHART_INSTANCES[chart.id] = new Chart(ctx, {
            type: mainType,
            data: {
                labels: xLabels,
                datasets: datasets
            },
            options: {
                responsive: true,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                onClick: (e, activeElements, chart) => {
                    const points = chart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, true);
                    if (points.length) {
                        const firstPoint = points[0];
                        const datasetIndex = firstPoint.datasetIndex;
                        const index = firstPoint.index;
                        const dataset = chart.data.datasets[datasetIndex];

                        if (dataset.label === 'Clinical Notes') {
                            const pt = dataset.data[index];
                            if (pt) {
                                showCustomNoteModal(pt.date, pt.note, pt.photo);
                            }
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: dynamicTitle,
                        font: { size: 14 }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                if (context.dataset.label === 'Clinical Notes') {
                                    return context.raw.note ? context.raw.note.substring(0, 50) + (context.raw.note.length > 50 ? '...' : '') : 'Note';
                                }
                                let label = context.dataset.label || '';
                                if (label) label += ': ';
                                if (context.parsed.y !== null) label += context.parsed.y;
                                return label;
                            },
                            afterBody: function(context) {
                                const noteItem = context.find(i => i.dataset.label === 'Clinical Notes');
                                if (noteItem && noteItem.raw && noteItem.raw.note) {
                                    return '\nNote: ' + noteItem.raw.note;
                                }
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        ticks: {
                            maxTicksLimit: 20,
                            autoSkip: true
                        },
                        stacked: isStacked
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: { display: true, text: 'Primary Axis' },
                        stacked: isStacked,
                        ...leftScale
                    },
                    y1: {
                        type: 'linear',
                        display: hasRight,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false,
                        },
                        title: { display: true, text: 'Secondary Axis' },
                        stacked: isStacked,
                        ...rightScale
                    },
                }
            },
            plugins: [weekPartitionPlugin]
        });
    }

    function renderTable() {
        const thead = document.getElementById('tableHeadRow');
        const tbody = document.getElementById('tableBody');

        // Headers
        let htmlHead = '<th>Date</th><th>Week</th>';
        CONFIG.overview_columns.forEach(m => {
            htmlHead += `<th>${METRICS_META[m]?.label || m}</th>`;
        });
        thead.innerHTML = htmlHead;

        // Body
        let htmlBody = '';
        if (CURRENT_DATA.dates) {
            for (let i = 0; i < CURRENT_DATA.dates.length; i++) {
                htmlBody += `<tr>
                    <td>${CURRENT_DATA.dates[i]}</td>
                    <td>${CURRENT_DATA.weeks[i]}</td>`;

                CONFIG.overview_columns.forEach(m => {
                    let val = CURRENT_DATA[m] ? CURRENT_DATA[m][i] : '-';
                    // Format
                    if (typeof val === 'number') {
                        // Check unit
                        if (METRICS_META[m]?.unit === '%') val = val.toFixed(2) + '%';
                        else if (METRICS_META[m]?.unit) val = val + ' ' + METRICS_META[m].unit;
                    }
                    htmlBody += `<td>${val}</td>`;
                });

                htmlBody += `</tr>`;
            }
        }
        tbody.innerHTML = htmlBody;
    }

    // --- Modal Actions ---

    function prepareAddChart() {
        document.getElementById('chartForm').reset();
        document.getElementById('chartId').value = '';
        document.getElementById('chartModalTitle').innerText = 'Add Chart';
        document.getElementById('btnDeleteChart').style.display = 'none';

        // Uncheck all
        document.querySelectorAll('#leftAxisMetrics input').forEach(c => c.checked = false);
        document.querySelectorAll('#rightAxisMetrics input').forEach(c => c.checked = false);
        // Reset types to default
        document.querySelectorAll('select[id*="_type_"]').forEach(s => s.value = '');
    }

    function editChart(chartId) {
        const chart = CONFIG.charts.find(c => c.id === chartId);
        if (!chart) return;

        prepareAddChart();
        document.getElementById('chartId').value = chart.id;
        document.getElementById('chartTitle').value = chart.title;
        document.getElementById('chartType').value = chart.chart_type;
        document.getElementById('isTemplate').checked = chart.is_template;
        document.getElementById('chartModalTitle').innerText = 'Edit Chart';
        document.getElementById('btnDeleteChart').style.display = 'block';

        // Check boxes
        if (chart.config.metrics) {
            chart.config.metrics.forEach(m => {
                const el = document.getElementById('left_check_' + m);
                if (el) el.checked = true;
                // Set type
                const typeSel = document.getElementById('left_type_' + m);
                if (typeSel && chart.config.types && chart.config.types[m]) {
                    typeSel.value = chart.config.types[m];
                }
            });
        }
        if (chart.config.metrics_right) {
            chart.config.metrics_right.forEach(m => {
                const el = document.getElementById('right_check_' + m);
                if (el) el.checked = true;
                // Set type
                const typeSel = document.getElementById('right_type_' + m);
                if (typeSel && chart.config.types && chart.config.types[m]) {
                    typeSel.value = chart.config.types[m];
                }
            });
        }

        const modal = new bootstrap.Modal(document.getElementById('chartModal'));
        modal.show();
    }

    async function saveChart() {
        const id = document.getElementById('chartId').value;
        const title = document.getElementById('chartTitle').value;
        const type = document.getElementById('chartType').value;
        const isTemplate = document.getElementById('isTemplate').checked;

        // Collect metrics and their specific types
        const leftMetrics = [];
        const rightMetrics = [];
        const metricTypes = {};

        document.querySelectorAll('#leftAxisMetrics input:checked').forEach(el => {
            const m = el.value;
            leftMetrics.push(m);
            const t = document.getElementById('left_type_' + m).value;
            if (t) metricTypes[m] = t;
        });

        document.querySelectorAll('#rightAxisMetrics input:checked').forEach(el => {
            const m = el.value;
            rightMetrics.push(m);
            const t = document.getElementById('right_type_' + m).value;
            if (t) metricTypes[m] = t;
        });

        if (!title || (leftMetrics.length === 0 && rightMetrics.length === 0)) {
            alert("Please provide a title and select at least one metric.");
            return;
        }

        const payload = {
            id: id ? parseInt(id) : null,
            title: title,
            chart_type: type,
            is_template: isTemplate,
            config: {
                metrics: leftMetrics,
                metrics_right: rightMetrics,
                types: metricTypes
            }
        };

        await fetch(`/api/house/${HOUSE_ID}/charts`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });

        location.reload();
    }

    async function deleteChart() {
        const id = document.getElementById('chartId').value;
        if (!id) return;
        if (!confirm("Are you sure you want to delete this chart?")) return;

        await fetch(`/api/charts/${id}`, { method: 'DELETE' });
        location.reload();
    }

    async function saveTableConfig() {
        const cols = Array.from(document.querySelectorAll('#tableMetricsList input:checked')).map(el => el.value);

        await fetch(`/api/house/${HOUSE_ID}/overview`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ columns: cols })
        });

        location.reload();
    }

    // --- Templates ---
    async function loadTemplates() {
        const res = await fetch('/api/templates');
        const templates = await res.json();

        const list = document.getElementById('templatesList');
        list.innerHTML = '';

        if (templates.length === 0) {
            list.innerHTML = '<div class="alert alert-info">No templates found. Save a chart as a template first.</div>';
            return;
        }

        templates.forEach(t => {
            const el = document.createElement('a');
            el.className = 'list-group-item list-group-item-action';
            el.href = '#';
            el.innerHTML = `
                <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">${t.title}</h5>
                    <small>from ${t.house_name}</small>
                </div>
                <p class="mb-1">Type: ${t.chart_type} | Metrics: ${t.config.metrics?.length || 0}</p>
            `;
            el.onclick = function() {
                applyTemplate(t);
            };
            list.appendChild(el);
        });
    }

    async function applyTemplate(template) {
        if (!confirm(`Import chart "${template.title}"?`)) return;

        const payload = {
            id: null,
            title: template.title,
            chart_type: template.chart_type,
            is_template: false, // Imported is not template by default
            config: template.config
        };

        await fetch(`/api/house/${HOUSE_ID}/charts`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });

        location.reload();
    }

    // --- Table Export ---
    function exportTableToExcel() {
        // Simple CSV export
        let csv = [];
        const rows = document.querySelectorAll("#overviewTable tr");

        for (let i = 0; i < rows.length; i++) {
            let row = [], cols = rows[i].querySelectorAll("td, th");
            for (let j = 0; j < cols.length; j++)
                row.push('"' + cols[j].innerText + '"');
            csv.push(row.join(","));
        }

        const csvFile = new Blob([csv.join("\n")], {type: "text/csv"});
        const link = document.createElement("a");
        link.download = `Flock_${FLOCK_ID}_Overview.csv`;
        link.href = window.URL.createObjectURL(csvFile);
        link.style.display = "none";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function showCustomNoteModal(date, text, photoUrl) {
        document.getElementById('customNoteModalTitle').innerText = 'Clinical Note: ' + date;
        document.getElementById('customNoteModalText').innerText = text;
        document.getElementById('customNoteModalDate').innerText = date;

        const imgDiv = document.getElementById('customNoteModalPhoto');
        const img = imgDiv.querySelector('img');
        if (photoUrl) {
            img.src = photoUrl;
            imgDiv.style.display = 'block';
        } else {
            imgDiv.style.display = 'none';
        }

        const modal = new bootstrap.Modal(document.getElementById('customNoteModal'));
        modal.show();
    }
</script>

<!-- Bootstrap Icons -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">

{% endblock %}
